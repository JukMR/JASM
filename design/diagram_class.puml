@startuml diagram_class

skinparam linetype polyline
skinparam classFontName Helvetica
skinparam ClassFontSize 14
skinparam ArrowColor MidnightBlue
skinparam groupInheritance 2


skinparam class {

}

package "Stringify_Asm" {

    class Instruction {
        + mnemonic: str
        + operands: List[str]
        + stringify() -> str
    }

    class InstructionObserver {
        + observe_instruction(inst: Instruction) : Optional[Instruction]
    }

    abstract class Disassembler {
        {abstract} binary: str
        {abstract} disassemble() -> str
    }

    class GNUObjdumpDisassembler {
        + program
    }

    class LLvmObjdumpDisassembler {
        + program
    }

    class NullDisassembler {
        + disassemble() -> str
    }

    abstract class AsmParser {
        + assembly: str
        {abstract} parse(file, IConsumer) -> List[Instruction]
    }

    class LlvmObjdumpParser {
        + parse(file, IConsumer) -> List[Instruction]
    }

    abstract class IInstructionsProducer {
        {abstract} process_file(file, IConsumer) -> List[Instruction]
    }

    class ComposableProducer {
        + disassembler: Disassembler
        + parser: AsmParser
        + process_file(file, IConsumer) -> List[Instruction]
    }

    class GNUObjdumpParser {
        + parse(file, IConsumer) -> List[Instruction]
    }

    class ShellDissasembler {
        - binary: str
        - output_path: str
        - program: str
        - flags: str
        + disassemble() -> None
    }

    class InstConsumer {
        + finalize() -> str
    }

    class InstProducerFactory {

    }
}

package "Regex" {

    abstract class File2Regex {
        {abstract} load_file(file) : Any
        {abstract} produce_regex()
    }

    class Yaml2Regex {
        - loaded_file: Any
        - directive_processor: DirectiveProcessor
        + load_file(file: PathStr) : Any
        + produce_regex() -> str
    }

    class OperandsHandler {
        - operands: OperandListType
        + get_regex() -> str
    }

    class DirectiveProcessor {
        - strategy: IDirectiveStrategy
        + execute_strategy(): str
    }

    interface IDirectiveProcessor {
        pattern : Dict
        include_list : Optional
        exclude_list : Optional
        times : Optional
        operands : Optional
        times_regex: Optional[str]
        operand_regex: str

        join_instructions(inst_list: List[str], operand: str) -> str
        get_times(pattern: PatternDict) -> TimesType
        {abstract}process() -> str
    }


    class AnyDirectiveProcessor {
        exclude_list_regex : str
        include_list_regex : str
        operand_regex : str
        times_regex : Optional[str]

        + process() -> str
    }

    class NotDirectiveProcessor {
        operand_regex : str
        times_regex : Optional[str]

        + process() -> str
    }

    class SingleDirectiveProcessor {
        operand_regex : str
        times_regex : Optional[str]

        process() -> str
    }



}

' Strategy Pattern Relationships
DirectiveProcessor -[#red,thickness=1]o IDirectiveProcessor: uses
IDirectiveProcessor  <|-- AnyDirectiveProcessor
IDirectiveProcessor  <|-- SingleDirectiveProcessor
IDirectiveProcessor  <|-- NotDirectiveProcessor

Yaml2Regex --up> AnyDirectiveProcessor : executes_strategy
Yaml2Regex --up> SingleDirectiveProcessor : executes_strategy
Yaml2Regex --up> NotDirectiveProcessor : executes_strategy
Yaml2Regex --o DirectiveProcessor: has


IDirectiveProcessor -o OperandsHandler


File2Regex <|-- Yaml2Regex



AsmParser <|--- GNUObjdumpParser
AsmParser <|--- LlvmObjdumpParser

Disassembler <|-- ShellDissasembler
ShellDissasembler <|-- GNUObjdumpDisassembler
ShellDissasembler <|-- LLvmObjdumpDisassembler
Disassembler <|--- NullDisassembler

IInstructionsProducer <|-- ComposableProducer
ComposableProducer --o Disassembler
ComposableProducer --o AsmParser

IInstructionsProducer <.. InstProducerFactory :creates


ComposableProducer -> InstConsumer : Instruction Stream

InstConsumer --> InstructionObserver : calls many
@enduml
