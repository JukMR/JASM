@startuml diagram_class

skinparam linetype polyline
skinparam classFontName Helvetica
skinparam ClassFontSize 14
skinparam ArrowColor MidnightBlue
skinparam groupInheritance 2


skinparam class {

}

' PACKAGES AND ELEMENTS DEFINITIONS

package "Stringify_Asm" {

    class Instruction {
        + addrs: str
        + mnemonic: str
        + operands: List[str]
        + stringify() -> str
    }

    interface IInstructionProducer {
        {abstract} + process_file(file: str, iConsumer: IConsumer) -> None
    }

    abstract class Disassembler {
        {abstract} + disassemble(input_file: str) -> str
    }

    class ComposableProducer {
        + disassembler: Disassembler
        + parser: AsmParser
        + __init__(disassembler: Disassembler, parser: AsmParser) -> None
        + process_file(file: str, iConsumer: IConsumer) -> None
    }

    package Disassemblers {

        class ShellDisassembler {
            - program: str
            - flags: str
            + __init__(program: str, flags: str) -> None
            + disassemble(input_file: str) -> str
        }

        class GNUObjdumpDisassembler {
            + __init__(flags: str) -> None

        }

        class LLvmObjdumpDisassembler {
            + __init__(flags: str) -> None
        }

        class NullDisassembler {
            + disassemble(input_file: str) -> str
        }
    }



    abstract class AsmParser {
        {abstract} parse(file: str, iConsumer: IConsumer) -> None:

    }

    package Parsers{

        class LlvmObjdumpParser {
            + parse(file: str, iConsumer: IConsumer) -> None
        }


        class GNUObjdumpParser {
            + parse(file: str, iConsumer: IConsumer) -> None
        }

    }




    interface IMatchedObserver {
        {abstract} + matched: bool
        {abstract} + stringified_instructions: str
        {abstract} + regex_matched(addr: str) -> None
        {abstract} + finalize() -> None
    }

    interface IConsumer {
        + __init__(matched_observer: IMatchedObserver) -> None
        {abstract} + consume_instruction(inst: Instruction) -> None
        {abstract} + finalize() -> None
    }

    class InstructionObserverConsumer {
        - matchedObserver: IMatchedObserver
        - observedInstructions: List[Instruction]
        + __init__(matchedObserver: IMatchedObserver) -> None
        + consume_instruction(inst: Instruction) -> None
        + observe_instruction(inst: Instruction) -> Optional[Instruction]
        + finalize() -> None
    }

    class CompleteConsumer {
        - matchedObserver: IMatchedObserver
        - instructions: List[Instruction]
        + __init__(matchedObserver: IMatchedObserver) -> None
        + consume_instruction(inst: Instruction) -> None
        + finalize() -> None
    }

    class StreamConsumer {
        - matchedObserver: IMatchedObserver
        - streamBuffer: StreamBuffer
        + __init__(matchedObserver: IMatchedObserver) -> None
        + consume_instruction(inst: Instruction) -> None
        + finalize() -> None
    }

    class MatchedObserver {
        - isMatched: bool
        - instructions: List[Instruction]
        + regex_matched(addr: str) -> None
        + finalize() -> None
        + matched: bool
        + stringified_instructions: str
    }

}

package "Regex" {

    abstract class File2Regex {
        {abstract} load_file(file) : Any
        {abstract} produce_regex()
    }

    class Yaml2Regex {
        - loaded_file: Any
        - directive_processor: DirectiveProcessor
        + load_file(file: PathStr) : Any
        + produce_regex() -> str
    }

    class OperandsHandler {
        - operands: OperandListType
        + get_regex() -> str
    }

    class DirectiveProcessor {
        - strategy: IDirectiveStrategy
        + execute_strategy(): str
    }

    interface IDirectiveProcessor {
        pattern : Dict
        include_list : Optional
        exclude_list : Optional
        times : Optional
        operands : Optional
        times_regex: Optional[str]
        operand_regex: str

        join_instructions(inst_list: List[str], operand: str) -> str
        get_times(pattern: PatternDict) -> TimesType
        {abstract}process() -> str
    }


    class AnyDirectiveProcessor {
        exclude_list_regex : str
        include_list_regex : str
        operand_regex : str
        times_regex : Optional[str]

        + process() -> str
    }

    class NotDirectiveProcessor {
        operand_regex : str
        times_regex : Optional[str]

        + process() -> str
    }

    class SingleDirectiveProcessor {
        operand_regex : str
        times_regex : Optional[str]

        process() -> str
    }

}

package "Observers" {
        class TagOutofAddrsRangeJumps {
        - max_addr: str
        + __init__(max_addr: str) -> None
        + consume_instruction(inst: Instruction) -> None
        + deal_with_instruction_out_of_range(inst: Instruction) -> Instruction
    }

    class CheckAddrRangeJumpsNearBadInstruction {
        - livehood: int
        - current_instructions_index: int
        + __init__(distance: int) -> None
        + consume_instruction(inst: Instruction) -> None
        + tag_instruction(inst: Instruction) -> Instruction
    }

    class RemoveEmptyInstructions {
        + observe_instruction(inst: Instruction) -> Optional[Instruction]
    }
}


' RELATIONS

' Regex
DirectiveProcessor -[#red,thickness=1]o IDirectiveProcessor: uses
IDirectiveProcessor  <|-- AnyDirectiveProcessor
IDirectiveProcessor  <|-- SingleDirectiveProcessor
IDirectiveProcessor  <|-- NotDirectiveProcessor

Yaml2Regex --up> AnyDirectiveProcessor : executes_strategy
Yaml2Regex --up> SingleDirectiveProcessor : executes_strategy
Yaml2Regex --up> NotDirectiveProcessor : executes_strategy
Yaml2Regex --o DirectiveProcessor: has

IDirectiveProcessor -o OperandsHandler

File2Regex <|-- Yaml2Regex


' Stringify_Asm

' Use this hidden element to display producer at left and consumer at right
IConsumer -[hidden]> IInstructionProducer :uses
IInstructionProducer -right> IConsumer :uses

' Producer
IInstructionProducer <|-- ComposableProducer

AsmParser <|--- GNUObjdumpParser
AsmParser <|--- LlvmObjdumpParser

Disassembler <|-- ShellDisassembler
ShellDisassembler <|-- GNUObjdumpDisassembler
ShellDisassembler <|-- LLvmObjdumpDisassembler
Disassembler <|--- NullDisassembler

' Hidden arrow to draw the relation Disassembler -> NullDisassembler in the correct level
NullDisassembler -[hidden]> LLvmObjdumpDisassembler: uses


ComposableProducer --o Disassembler
ComposableProducer --o AsmParser


' Consumer
InstructionObserverConsumer -o IMatchedObserver
InstructionObserverConsumer <|-- CompleteConsumer
InstructionObserverConsumer <|-- StreamConsumer
IMatchedObserver <|-- MatchedObserver
IConsumer <|-- InstructionObserverConsumer




' Observers


@enduml
